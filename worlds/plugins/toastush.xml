<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, April 12, 2021, 3:48 PM -->
<!-- MuClient version 5.05 -->

<!-- Plugin "Toastush" generated by Plugin Wizard -->

<muclient>
<plugin
   name="toastush_ng"
   author="Erick Rosso+community"
   id="843d2f53cb3685465bda7d4a"
   language="Lua"
   date_written="2021-04-12 15:47:28"
   requires="5.05"
   version="4.0"
   save_state="y"
   >

 <description trim="y">

    Welcome to the Miriani MUSHclient soundpack: Toastush-NG (Next Generation).
    Enhanced with foreground audio controls, improved architecture, and bug fixes.
    
----------------------------------------

    To get started with configuring the soundpack, type: `toastush:config or toastush:config [option]'
    To view information about the currently running script type: `toastush:info'
    To view the changelog, type: `toastush:changes'
    To send the registration string, type: `toastush:register'
    To reload the updater, type: `toastush:updater-reload or toastush:u-rel'
    To toggle soundpack minimal mode type: `toastush:minimal or toastush:min'



    To fetch updates type: `update'
      - More help about using the updater can be found by typing `update --help'


    To view valid starmap filters type: `sm.help'
    To view valid scan filters type: `sc.help'

    To view this help type: `'toastush:help'


-------------------Key Bindings--------------

    - Audio:
    F9: Toggle global mute.
    Ctrl+F9: Toggle foreground sounds (sounds only when window has focus).
    F10: Cycle forward through audio groups.
    Shift+F10: Cycle backward through audio groups.
    F11: Decrease group volume.
    F12: Increase group volume.

    - Miscellaneous:
    ALT+SHIFT+U: Open last url.
    CTRL+L: Initialize audio settings. (Helpful in the case of switching soundcards.)
    ALT+SHIFT+I: Read the info bar.




----------------------------------------
 
    ** Once in the game, tune a metaf frequency communicator to 0.07 for in game support. **
</description>
</plugin>


<!--  Get our standard constants -->

<!-- Constants are now loaded via require in the script section -->
<!--  Plugin help  -->

<!--  Timers  -->

<timers>

  <timer
   enabled="y"
   active_closed="y"
   hour="1"
   second="0"
   offset_second="0.00"
   script="detect_update_when_idle"
   send_to="14"
  >
  </timer>


  <timer
   enabled="y"
   name="heartbeat"
   active_closed="y"
   hour="0"
   second="1"
   offset_second="0.00"
   send_to="14"
  >
  <send>
   heartbeat = heartbeat + 1

   local roundtime_option = config:get_option("roundtime")
   if (roundtime_option.value == "yes") and
   (roundtime == 1) then
    mplay("misc/roundtime")
   end -- if round time

  
   if (roundtime &gt; 0) then
    roundtime = roundtime - 1
   end -- if

   if (stuntime ~= 0) then
    stuntime = stuntime - 1
   end -- if

   if (stuntime &lt; 0) then
    stuntime  = 0
   end -- if

   if (stuntime == 0)
   and (stunned == true) then
    stunned = false
    if (environment) and (environment.line) then
      replicate_line(environment.line)
    else
      stop("ambiance", nil, 1, 0.5)
    end -- if
   end -- if

show_paralyzed(roundtime, stuntime)

    if (IsConnected()) then 
      if (heartbeat == ping_after_heartbeat) then
             Execute("#$#SOUNDPACK_PING")
      end -- if

   end -- if

   if (heartbeat &gt;= reset_heartbeat) then
       heartbeat = 0
   end -- if

</send>
  </timer>




</timers>


<!-- Triggers -->

<triggers>

  <trigger
 enabled="y"
   script="OnMSP"
   name="MSP"
   match="^(!!SOUND\(.+\))$"
   regexp="y"
   omit_from_output="y"
   send_to="14"
>
  </trigger>

  <trigger
   enabled="y"
   script="OnURL"
   name="http"
   match="((?:https?|ftp|telnet|rsync|mailto|gopher)://[[:graph:]]+[^&quot;])"
   regexp="y"
   send_to="12"
   keep_evaluating="y"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^\^(Creating|Deleting|Updating) Files: \d+%\.{3}$"
   regexp="y"
   omit_from_output="y"
   omit_from_log="y"
   send_to="14"
  >
  <send>notify("info", "%0", 1)</send>
  </trigger>
  <trigger
   enabled="n"
   name="MCP"
   match="^#\$#mcp(-\w+)?(?:-(\w+))? (\S+)(?: (.*))?$"
   regexp="y"
   send_to="12"
   omit_from_output="y"
   omit_from_log="y"
  >
  <send>
   MCP:handle_message("%0")
  </send>
  </trigger>


</triggers>

<aliases>
  <alias
   enabled="y"
   script="help"
   match="^toastush:help$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   script="info"
   match="^toastush:info$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   script="config_main_menu"
   match="^toastush:config(?:ure)?$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   match="^toastush:config(?:ure)? (\w+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
  >
  <send>config_secondary_menu("%1")</send>
  </alias>


  <alias
   enabled="y"
   script="notepad_changelog"
   match="^toastush:changes$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Accessing the changelog...", 1)</send>
  </alias>

  <alias
   enabled="y"
   script="register"
   match="^toastush:register$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Sending Toastush registration...", 1)</send>
  </alias>

  <alias
   enabled="y"
   match="^toastush:u(pdater)?-rel(oad)?$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>
   notify("info", "Reloading updater...")
   local ok, msg = ReloadPlugin(UPDATE_ID)
   if (ok == 0) then
     notify("info", "Updater reload complete.")
   else
     notify("info", "Updater reload failed.")
   end -- if

  </send>
  </alias>



  <alias
   enabled="y"
    name="minimal_mode_alias"
   script="toggle_minimal_mode"
   match="^toastush:min(?:imal)?$"
   regexp="y"
   send_to="12"
  >
  </alias>

  <alias
   enabled="y"
   name="fsounds_alias"
   match="^fsounds$"
   regexp="y"
   send_to="12"
  >
  <send>
    local current = config:get_option("foreground_sounds").value
    if current == "yes" then
      config:set_option("foreground_sounds", "no")
      Execute("tts_interrupt Sounds will play in background")
    else
      config:set_option("foreground_sounds", "yes")
      Execute("tts_interrupt Sounds only when window has focus")
    end
    mplay("misc/mouseClick", "notification", nil, nil, nil, nil, nil, true)
    config:save()
  </send>
  </alias>




  <alias
   enabled="y"
   send_to="12"
   match="^toastush:classic$"
   ignore_case="y"
   regexp="y"
  >
   <send>local current = config:get_option("classic_audio_mode").value
if current == "modern" then
  config:set_option("classic_audio_mode", "classic")
  notify("info", "Classic audio mode enabled")
else
  config:set_option("classic_audio_mode", "modern")
  notify("info", "Modern audio mode enabled")
end
config:save()</send>
  </alias>


</aliases>

<script>
<![CDATA[
require("json")

scripts = "lua/miriani/scripts/"

require(scripts.."init")

MSP, GMCP = 90, 201 
timeout = 120
script = 12
registry = "Toastush-NG"
heartbeat = 0
reset_heartbeat = 60
ping_after_heartbeat = 30
roundtime, stuntime = 0, 0
stunned = false




---------------------
-- Macros
Accelerator('F1', 'toastush:config')
AcceleratorTo ("F10", 'forward_cycle_audio_groups()', script) -- cycle forward sound groups.
AcceleratorTo ("SHIFT+F10", 'previous_cycle_audio_groups()', script) -- cycle previous sound groups.

AcceleratorTo("F9", 'toggle_mute()', script)
AcceleratorTo("CTRL + F9", [[
  local current = config:get_option("foreground_sounds").value
  if current == "yes" then
    config:set_option("foreground_sounds", "no")
    Execute("tts_interrupt Sounds will play in background")
  else
    config:set_option("foreground_sounds", "yes")
    Execute("tts_interrupt Sounds only when window has focus")
  end
  mplay("misc/mouseClick", "notification", nil, nil, nil, nil, nil, true)
  config:save()
]], script)
AcceleratorTo("F11", 'decrease_attribute("volume")', script)
AcceleratorTo("F12", 'increase_attribute("volume")', script)
AcceleratorTo("ALT+SHIFT+U", 'open_url()', script)
AcceleratorTo("Esc", [[
  if config:get_option("escape_abort").value == "yes" then
    Send("@abort")
  else
    SetCommandSelection(1, #GetCommand())
    PasteCommand("")
  end
]], script)
AcceleratorTo("ctrl+l", [[
  notify("info", "Reloading audio settings...")
  initialize_audio()
  notify("info", "Audio settings initialized.")]], script)

AcceleratorTo("ALT+SHIFT+I", [[
  local line = ""



  for k,v in pairs(infobar_t) do
    line = line..v.." - "
  end -- for
  notify("info", line, 1)

]], script)







---------------------
-- script routines
-- Load constants
local constants = require(scripts.."constants")

-- Load constants into global scope
for k, v in pairs(constants) do
  _G[k] = v
end

local sp_options = require(scripts.."options")
local audio_options = require(scripts.."audio")

function OnPluginInstall()
  math.randomseed(os.time())
  print("Welcome to the MUSHclient Miriani soundpac: [version: ", VERSION, "] For help see toastush:help.")
  print("Toastush now offers a Discord community for support. View toastush:help to get more information.")

  initialize_audio()
  if IsConnected() then
    register()
  end -- if

  -- janitor code
  janitor()

  if (GetVariable("proxiani_enabled")) then
    EnableGroup("starmap", 0)
  end -- if

  -- check for minimal mode.
  if (GetVariable("minimal_mode") == "1") then
    toggle_minimal_groups(0)
  end -- if

end -- OnPluginInstall

function OnPluginSaveState()
  config:save()
end -- OnPluginSave

function OnPluginConnect()
  --register()
  mplay("music/theme", "other", 1)
end -- OnPluginConnect

function OnPluginDisconnect()
  DeleteVariable("proxiani_enabled")
  stop() -- stop all audio.
end -- OnPluginDisconnect

function OnPluginClose()
  -- Clean up all audio streams properly
  if sounds and sounds.cleanup_all_streams then
    sounds.cleanup_all_streams()
  else
    stop() -- fallback to basic stop
  end

  -- Clean up BASS audio system
  if BASS and BASS.IsInitialized and BASS:IsInitialized() then
    BASS:Free()
  end
end -- OnPluginClose

function OnPluginSend(text)
  local s = text

  -- Convert smart quotes and other special characters to ASCII equivalents
  -- This prevents the MOO server from dropping non-ASCII characters
  s = s:gsub("\147", "\"")  -- Left double quote (U+0093)
  s = s:gsub("\148", "\"")  -- Right double quote (U+0094)
  s = s:gsub("\145", "'")   -- Left single quote (U+0091)
  s = s:gsub("\146", "'")   -- Right single quote (U+0092)
  s = s:gsub("\160", " ")   -- Non-breaking space (U+00A0)
  s = s:gsub("\150", "-")   -- En dash (U+0096)
  s = s:gsub("\151", "-")   -- Em dash (U+0097)
  s = s:gsub("\133", "...")  -- Ellipsis (U+0085)

  -- If text was modified, send the converted version instead
  if s ~= text then
    Send(s)
    return false  -- Don't send the original
  end

  return true  -- Send the original text
end -- OnPluginSend

function OnPluginLoseFocus()

  -- Reset focus flag.
  focusWindow = nil

  -- Call our focus handling function
  pause_all_sounds()

end -- OnPluginLoseFocus

function OnPluginGetFocus()

  -- Set focus flag.
  focusWindow = true

  -- Call our focus handling function
  resume_all_sounds()

end -- OnPluginGetFocus

function OnPluginTelnetRequest (type, data)
  if data == "WILL" then
    if type == GMCP then
      notify("info", "Enabled GMCP")
            return true
    elseif  type == MSP then
      notify("info", "Enabled MSP")
      return true
    end -- if
  end -- if
end -- function OnPluginTelnetRequest

function OnPluginTelnetSubnegotiation (type, data)
   if type == GMCP then
    gmcp_handler(data)
  end -- if
end -- function OnPluginTelnetSubnegotiation

function OnPluginBroadcast(msg, id, name, text)
  
  if id == "54846c23d8b15594e7eb4b8a" then
    if text=="output_boundary" then
      mplay("misc/boundary")
          end
  elseif id == "843d2f53cb3685465bda7d4c" then
    local message_type, data = text:match("([^|]+)|?(.*)")
    message_type = message_type or text
    
    if message_type == "register_audio_group" then
      -- Register audio group dynamically (format: "groupname,display_name")
      local group_name, display_name = data:match("([^,]+),?([^,]*)")
      if group_name then
        -- Add to config.audio table for F10 cycling (preserve existing volume if group exists)
        if not config.audio[group_name] then
          config.audio[group_name] = {volume=50, pan=0}
        end

        -- Also add the config option for persistence (preserve existing value)
        local option_name = group_name .. "_volume"
        display_name = display_name ~= "" and display_name or (group_name:gsub("^%l", string.upper) .. " Volume")

        if not config:get_option(option_name) then
          -- Use existing volume from config.audio if available, otherwise default to 50
          local existing_volume = config.audio[group_name] and config.audio[group_name].volume or 50
          config:add_option("volume", option_name, display_name, existing_volume, "number", "volume")
        end
      end
    elseif message_type == "unregister_audio_group" then
      -- Remove audio group (format: "groupname")
      if data and config.audio[data] then
        config.audio[data] = nil
      end
    elseif message_type == "play_sound" then
      -- Parse sound file and group from data (format: "filepath,group")
      local filepath, group = data:match("([^,]+),([^,]+)")
      if filepath and group then
        mplay(filepath, group)
      end
    elseif message_type == "set_audio_volume" then
      -- Set audio group volume (format: "groupname,volume")
      local group_name, volume = data:match("([^,]+),([^,]+)")
      if group_name and volume then
        local vol_num = tonumber(volume)
        if vol_num and config.audio[group_name] then
          config:set_attribute(group_name, "volume", vol_num)
        end
      end
    elseif message_type == "get_audio_volume" then
      -- Get audio group volume and broadcast back (format: "groupname")
      local group_name = data
      if group_name and config.audio[group_name] then
        local volume = config:get_attribute(group_name, "volume") or 100
        BroadcastPlugin(999, "audio_volume_reply|" .. group_name .. "," .. volume)
      end
    end
  elseif id == UPDATE_ID then
    -- Updater plugin communication
    local info = json.decode.decode(text)

    for i, u in pairs(info.update) do
      local name = u[i]

      if type(name) == 'string' and string.find(name, "updater.xml") then
        notify("important", "The updater received an update. In order to apply changes, you must reload the plugin.\ntype: `toastush:updater-reload'")
        break
      end -- if
    end -- for

    if config:get_option("automatic_changelog").value == "yes" then
      notepad_changelog()
    end -- if
  else
    -- Other generic plugin communication handlers
    if msg == "register_audio_group" then
      -- Register audio group dynamically (format: "groupname,display_name")
      local group_name, display_name = text:match("([^,]+),?([^,]*)")
      if group_name then
        local option_name = group_name .. "_volume"
        display_name = display_name ~= "" and display_name or (group_name:gsub("^%l", string.upper) .. " Volume")

        if not config:get_option(option_name) then
          config:add_option("volume", option_name, display_name, 100, "number", "volume")
        end
      end
    elseif msg == "play_sound" then
      -- Parse sound file and group from text (format: "filepath,group")
      local filepath, group = text:match("([^,]+),([^,]+)")
      if filepath and group then
        mplay(filepath, group)
      end
    end
  end
end -- OnPluginBroadcast

function OnPluginCommandEntered()

  last_command_time = os.time()
  if (searchingScan) then
    searchingScan = false
    scan = nil
   classFilter = nil
  end -- if scan
end -- OnPluginCommandEnter

-- Combined with first OnPluginBroadcast function above


function gmcp_handler(data)

  -- Below follows a typical GMCP implementation.
  -- End users may wish to modify behavior.

  core, params = string.match(data, "([%a.]+)%s+(.*)")
  local info = json.decode(params)

  if core == "communication.channel" then
    Channel(info.channel, info.message, {"channels"})
  elseif core == "communication.say" then
    Channel("say", info.message, {"conversation"})
  elseif core == "communication.tell" then
    Channel("tell", info.message, {"tell"})
  end -- if
end -- gmcp_handler

function OnMSP(name, line, wc)

  local text = wc[1]
  local info = {
  file = string.match(text, "!![%u]+%(([%a%d%p]+).*%)"),
  type = string.match(text, "!![%u]+%(.*T=([%a%d]+).*%)"),
  volume = string.match(text, "!![%u]+%(.*V=([%d]+).*%)"),
  loop = string.match(text, "!![%u]+%(.*L=([%d]+).*%)"),
  continue = string.match(text, "!![%u]+%(.*C=([%d]+).*%)"),
  url = string.match(text, "!![%u]+%(.*U=([%a%d%p]+).*%)")
  }
  msp_handler(info)
end -- OnMSP

function msp_handler(info)

  -- Below follows a typical MSP implementation.
  -- End users may wish to modify behavior.

  play(info.file, info.type)
end -- msp_handler

function on_plugin_update()
  --  Externally called to indicate this plugin should be reloaded upon updates.
  return 1
end -- on_plugin_update

function janitor()

  -- Alert users of proxiani.
  local version = utils.split(VERSION, ".")
  if (tonumber(version[1]) < 3) then
    notify("info", [[

    Info: Beginning Toastush version 3.0.1 and onward, Toastush will now officially support popular Miriani proxy server, Proxiani.
    As a result, when the proxy server is detected, Toastush starmap commands will be disabled.
    Users can expect increased performance, shared features between clients, TLS connectivity and more!
    ]])

    notify("info",
    "See, "..PROXIANI.." for installation details.")

  end -- if


  -- Disable F1 windows help:
  if (GetGlobalOption("F1macro") == 0) then
    db = sqlite3.open(GetInfo (82))  -- open preferences
    db:exec('UPDATE prefs SET value = 1 WHERE name = "F1macro"')
    db:close()  -- close
    utils.reload_global_prefs ()
  end -- if

  -- plugins_updater no longer in use.

  local old_plugins = {
  ["fbd5b7cc1ef6acf827a3f4a1"] = "plugins_updater.xml",
  ["55e1d330539761f176fa0815"] = "indexer.xml", 
  } -- old_plugins

  table.foreach(old_plugins,
  function(id, name)
    if (IsPluginInstalled(id)) then
    print("plugin ", name, " is no longer in use. Unloading.")
    UnloadPlugin(id)
    end -- if
  end ) -- foreach

  -- need an index.
  local path = require("pl.path")
  if (not path.isfile(INDEX)) then
    notify("critical", string.format(
    "Warning: You appear to be missing the index file, '%s'. This file is necessary for updates. To generate the file now, type `index %s'", INDEX, INDEX))
  end -- if

  -- old version downloaded messy files.
  local dir = utils.readdir("*.ogg")
  local js = require("json.decode")
  local f = io.open("index-v5.manifest", "r")

  if (f and dir) then
    local t = f:read("*all")
    f:close()
    local info = js.decode(t)

    local paths = ""
    for path, _ in pairs(info) do
      paths = paths.." "..path
    end -- for

    for file, _ in pairs(dir) do
      if string.find(paths, file) then
        utils.shellexecute("cmd", "/C rmdir "..file, GetInfo(59), nil, 0)
      end -- if
    end -- for
  end -- if
end -- janitor

function detect_update_when_idle()

  if config:get_option("update_idle").value == "yes"
  and IsPluginInstalled(UPDATE_ID)
  and last_command_time ~= nil
  and (os.time() - last_command_time) >= IDLE_CUTOFF then
    Execute("update -q -f")
end -- if

end -- detect_update_when_idle

function toggle_minimal_mode(name, line, wc)
  local minimal_mode = (GetVariable("minimal_mode") == "1") and 1 or 0
  toggle_minimal_groups(minimal_mode)
  if (minimal_mode == 0) then


    SetVariable("minimal_mode", 1)
    notify("info", [[
    The soundpack is now in minimal mode.
    This mode disables the majority of triggers for a clean -- basic environment.
    Communications and miscellaneous gags will remain active.]])
  else

    DeleteVariable("minimal_mode")

    if (name == "minimal_mode_alias") then
      notify("info", "The soundpack is now in full -- regular mode.")
    end -- if
  end -- if
end -- minimal_mode

function toggle_minimal_groups(minimal_mode)
  for k,v in pairs(minimal_groups) do
    EnableGroup(v, minimal_mode)
  end -- for
  end -- toggle_minimal_groups

function initialize_audio()

  -- Clean up existing BASS instance if it exists
  if BASS and BASS.IsInitialized and BASS:IsInitialized() then
    BASS:Free()
  end

  -- Initialize LUA Audio system
  Audio = require("miriani.lib.audio.audio")

  -- Initialize the audio system
  if Audio.BASS then
    BASS = Audio.BASS()

    -- Initialize BASS
    if BASS then
      local init_result = BASS:Init(-1,44100,7)

      if init_result ~= 0 then
        Note("BASS initialization failed with error: " .. tostring(init_result))
      end
    end
  else
    Note("Audio.BASS not available")
  end

  -- Initialize volume settings
  local saved_vol = GetVariable("master_volume")
  local vol = saved_vol and tonumber(saved_vol) or 100

  if not saved_vol then
    SetVariable("master_volume", "100")
  end

  local init_result = config:init(sp_options, audio_options)
  if init_result ~= 0 then
    print("Warning: Config initialization failed with code:", init_result)
    print("Continuing with basic initialization...")
  end

end -- initialize_audio


function config_secondary_menu(option)
  local secondary_menu = config:render_menu_list(option)

  if type(secondary_menu) ~= 'table' then
    notify("info", string.format("Unable to locate menu group '%s`.", option))
    return 0
  end -- if 

  table.sort(secondary_menu)

  local group = config:get_option(next(secondary_menu)).group

  local title = string.format("%s Menu", group)

  repeat -- Display menu until escaped.
    mplay("misc/prompt")
      local second_choice = utils.listbox("Select Setting", title, secondary_menu)

    -- Step our user through a sequence to determine the value type.
    if config:is_option(second_choice) then

      if (not config:get_option(second_choice).type)
      or config:get_option(second_choice).type == "bool" then
        -- Interface for boolean value.
        local yes_no = utils.msgbox("Select an option.", title, "yesnocancel", "?")
        config:set_option(second_choice,
        yes_no ~= nil
        and yes_no ~= "cancel"
        and yes_no
        or config:get_option(second_choice).value)
      elseif config:get_option(second_choice).type == "function" then
        local newval = loadstring(config:get_option(second_choice).action)()

        if (newval and newval ~= -1) then
          config:set_option(second_choice, newval)
        else
         config:set_option(second_choice, config:get_option(second_choice).value)
        end -- if
      end -- if
    end -- if

    -- show changes:
    secondary_menu = config:render_menu_list(option)

  until not second_choice

  assert(config:save() == 0)
  mplay("misc/close")

end -- config_secondary_menu


function config_main_menu()
  local main_menu = config:render_menu_list()
  local title = string.format("%s Configuration Manager", GetPluginName()) 

  table.sort(main_menu)

  repeat -- Display main list.
    mplay("misc/prompt")

    local first_choice = utils.listbox("Select Setting", title, main_menu, 1)

    if first_choice then
      config_secondary_menu(main_menu[first_choice])
    end -- if

  until not first_choice

  mplay("misc/close")
end -- config_main_menu

link = {}
infobar_t = {}


---------------------------------


function infobar(id, message, clear)
  id = id or 1

  if clear then
    infobar_t = {}
  end -- if


  local foreground = RGBColourToName(config:get_option("info_foreground_color").value)
  local background = RGBColourToName(config:get_option("info_background_color").value)
  local data = {}
  infobar_t[id] = message

  table.foreach(infobar_t,
  function (k, v)
    data[#(data) + 1] = v
  end ) -- foreach
 
  InfoClear()
  InfoColour(foreground)
  InfoBackground(background)

  Info(
  table.concat(data, " -- "))

end -- infobar

function latency(name, line, wildcard)
  local ms = tonumber(wildcard[1]) or 0
  infobar("lag", string.format ("Latency: %d MS", ms))
end -- latency

function show_paralyzed(roundtime, stuntime)
  local roundtime = roundtime or 0
  local stuntime = stuntime or 0
  local paralyzed = roundtime + stuntime
  local sec = (paralyzed == 1) and "second" or "seconds"
  local id = "paralyzed"
  if (paralyzed > 0) then
  infobar(id, string.format ("paralyzed: %d %s", paralyzed, sec))
  else
    infobar_t[id] = nil
  end
end -- show_paralyzed

function help(name, line, wc)
  notify("info", string.format("%s", GetPluginInfo(GetPluginID(), 3)))
  ColourTell("silver", "black", "For Discord:     ")
print_hyperlink(DISCORD, DISCORD, "Click to join Discord")
end-- help

function info(name, line, wc)
  local ID = GetPluginID()
  notify("info", string.format("%s  --  version %s  --  Scripting-language: %s  -- Script-time: %s seconds",
  GetPluginInfo(ID, 1),
  VERSION,
  GetPluginInfo(ID, 5),
  GetPluginInfo(ID, 24)))
end -- info

function channel(name, line, wc)

  -- Requires the channel history plugin.

  assert (IsPluginInstalled ("6000a4c6f0e71d31fecf523d"), "channel_history could not be found")

  -- add record table of channel arguments
   for k,v in ipairs(wc) do
    -- Handle metaf buffers
    if string.match(v, "^metaf ") then
      -- Check if separate buffers is enabled
      local separate_buffers = config:get_option("metaf_separate_buffers")
      if separate_buffers and separate_buffers.value == "yes" then
        -- Use frequency/label-specific buffer (no need to check metaf_buffer)
        Execute("history_add " .. v .. "=" .. line)
      else
        -- Use single metaf buffer if it's enabled
        local metaf_buffer = config:get_option("metaf_buffer")
        if metaf_buffer and metaf_buffer.value == "yes" then
          Execute("history_add metaf=" .. line)
        end
      end
    elseif v == "metaf" then
      -- Regular metaf without frequency/label - only use if separate buffers is disabled
      local separate_buffers = config:get_option("metaf_separate_buffers")
      if separate_buffers and separate_buffers.value == "no" then
        local metaf_buffer = config:get_option("metaf_buffer")
        if metaf_buffer and metaf_buffer.value == "yes" then
          Execute("history_add metaf=" .. line)
        end
      end
      -- If separate buffers is enabled, ignore plain "metaf" completely
    else
      -- Normal buffer handling
      buffer = config:get_option(string.format("%s_buffer", v))
      if buffer ~= nil and buffer.value == "yes" then
        Execute("history_add "..v.."="..line)
      end
    end -- if metaf
  end -- for loop
end -- channel

function OnURL(name, line, wc)
  channel("url", wc[1], {"url"})
  --Add the url to a recent url buffer.
  link =
  {
    url = wc[1],
    timestamp = os.clock()
 }
end -- OnURL

function open_url()

  if (not link)
  or os.clock() - link.timestamp > timeout then
    notify("info", "No url to open.")
  else
    local url = link.url
    notify("info", "Opening "..url, 1)
    play("audio/mouseClick.ogg")
    OpenBrowser(url)
  end -- if
end -- open_url

function mplay(file, group, interrupt, pan, loop, slide, sec, ignore_focus)
  -- Miriani only play:
  local filepath

  if (config:get_option("alternate_audio").value == "yes") then
    local path = require("pl.path")
    local dir, fn = path.splitpath(file)
    local alt_file = ALTPATH..fn..ALT_EXTENSION

    -- Use find_sound_file for alternate audio to handle numbered variants
    if find_sound_file then
      local alt_path = find_sound_file(alt_file)
      if alt_path then
        filepath = alt_file
      end
    elseif (path.isfile(config:get("SOUND_DIRECTORY")..alt_file)) then
      filepath = alt_file
    end -- if
  end -- if

  -- Handle classic/modern audio selection - let the play function handle the logic
  if (not filepath) then
    filepath = string.format(SOUNDPATH.."%s%s", file, EXTENSION)
  end -- if

  play(filepath, group, interrupt, pan, loop, slide, sec, ignore_focus)
end -- mplay

function speech_interrupt(line)
  Execute("tts_interrupt "..line)
end -- speech_interrupt

function register()
  Send("#$#REGISTER_SOUNDPACK "..registry.." | "..VERSION.."\n")
  mplay("misc/negotiate", "notification")
end -- register

function GetAudioVolume(group_name)
  -- Function for other plugins to call directly
  if group_name and config.audio[group_name] then
    return tostring(config:get_attribute(group_name, "volume") or 100)
  end
  return ""
end -- GetAudioVolume

function set_environment(name, line, wc)
  environment = {}

  environment.name = name
  environment.line = line

  -- iterate through a table of flags
  -- and set all to true.
  -- split any deliminated tags and make them into their own truth value.

  for _, flag in ipairs(wc) do

    local names = utils.split(flag, " ")

    table.foreach(names,
    function(_, value)
      environment[string.lower(value)] = true
    end ) -- foreach
  end -- for

  -- ambiance
  ambiance(wc[#wc])
end -- set_environment

function playstep()

  if (not foundstep) or (not environment) or (not room) then
    return 0
  end -- if

  foundstep = false

  -- Stop here if aquatic
  if environment.marine
  or string.find (room, "aquatic") then
    mplay ("steps/swim")
    return 1
  end -- if

  local file
  local function set_type(t, type, check)
    local ok
    for _, keyword in ipairs(t) do
      if string.find(string.lower(check), keyword) then
        file = type
        ok = 1
        break
      end -- if
    end -- for

    return ok
  end -- check_type

  local deserts = {"desert", "beach", "shore", "sand", "wasteland"}
  local forests = {"forest", "woods", "field", "grass", "jungle", "glade", "dale", "farm", "glen"}
  local muddy = {"mud", "swamp", "marsh"}
  local flying = {"fly", "float", "hover"}
  local ducts = {"duct", "crawlspace"}
  local skating = {"skate", "rollerblade"}


  if set_type(deserts, "desert", room) == 1
  or set_type(forests, "forest", room) == 1
  or set_type(muddy, "mud", room) == 1
  or set_type(ducts, "duct", room) == 1
  or set_type(flying, "fly", footstep) == 1
  or set_type(skating, "skate", footstep) == 1 then
    mplay("steps/"..file)
    return 1
  end -- if

  -- play sounds if environment is starship.
  if environment.name == "starship" then
    mplay ("steps/starship")
    return 1
  end -- if

  -- play sound if environment is station 
  if environment.name == "station" then
    mplay ("steps/station")
    return 1
  end -- if

  if environment.indoors then
    mplay("steps/planet/indoors")
  else
    mplay("steps/planet/outdoors")
  end -- if

  return 1
end -- playstep

function playsocial(name, line, wc)
  -- Try to match social to file
  -- Game shortens the social text depending on what user typed.
  -- Randomly assign gender if nonbinary.
  if wc[2] == "nonbinary" then
    local genders = {"male","female"}
    wc[2] = genders[math.random(2)]
    end

  local socialtable = utils.readdir(config:get("SOUND_DIRECTORY")..SOUNDPATH.."social/"..wc[2].."/"..wc[1].."*"..EXTENSION)
  -- check that table exists
  if type(socialtable) ~= 'table' then

    if wc[2] ~= "neuter" then
      wc[2] = "neuter"

      return playsocial(name, line, wc)
    else
      return 0
    end -- recursive
  end -- if social exists

  local social = string.match (
  string.gsub (next(socialtable), "%d+", ""), "("..string.lower(wc[1]).."[%w%W]+)")
  social = string.gsub (social, EXTENSION, "")

  mplay ("social/"..wc[2].."/"..social, "socials")
end -- playsocial

function ambiance(roomtype)

  if (not environment)
  or not focusWindow
  or (cameraFeed)
  or (stunned)
  or config:get_option("background_ambiance").value == "no" then
    return 0
  end -- if

  local file = nil
  local fade = 0.8
  local names = utils.split(roomtype, " ")
  local rname = string.lower(names[#names])  

  if (environment.name == "starship") then

    local r = rooms.starship[rname]
    if environment.unpowered then
      file = "starship_unpowered"
    elseif r then
      file = r
    end -- if

  elseif (environment.name == "room") then
    if (environment.outdoors) then
      -- probably a roid.
      file = "asteroid"
    end -- if

  elseif (environment.name == "planet") then
    if environment.marine then
      file = "marine"
    elseif environment.rocky and environment.outdoors then
      file = "rocky"
    elseif environment.river then
      file = environment.outdoors and "lake" or "indoorRiver"
    elseif (environment.digsite) and (environment.indoors) and (environment.safe) then
      file = "cave"
    elseif environment.terrestrial and environment.outdoors then
      file = "terrestrial"
    elseif environment.transterrestrial and environment.outdoors then
      file = "transterrestrial"
    elseif environment.ice and environment.outdoors then
      file = "ice"

    end -- if

  elseif (environment.name == "vehicle") then
    if environment.unpowered then
      file = "starship_unpowered"
    else
      file = "vehicle"
    end -- if
  end -- if

  if (not file)
  and (rooms[environment.name]) then
    file = rooms[environment.name][rname]
  end -- if

  if file ~= nil then
    if file ~= ambianceFile then
      ambianceFile = file -- avoid repeat loops.
      mplay("ambiance/"..file, "ambiance", 1, nil, 1, 1, fade) 
    end -- if
  else
    stop("ambiance", nil, 1, fade) -- fade out previous
    ambianceFile = nil
  end -- if



end -- playambiance

function gagline(name, line, wc)
  if config:get_option("spam").value == "no" then
    print(line)
  else
  return 1
  end -- if

end -- gagline

function notepad_changelog(name, line, wc)

  local f = io.open(scripts.."changelog.txt", "r")
  if (f) then
    local text = f:read("*all")
    f:close()
    AppendToNotepad("Changelog", string.gsub(text, "\n", "\r\n"), "\r\n")
    ActivateNotepad("changelog")
  end -- if
end -- notepad_changelog

function replicate_line(line)
  Simulate("\r\n"..line.."\r\n")
end -- replicate_line

function print_hyperlink(l, text, hint, browser)
  browser = browser or 1
  local foreground = RGBColourToName(config:get_option("hyperlink_foreground_color").value)
  local background = RGBColourToName(config:get_option("hyperlink_background_color").value)

  Hyperlink(l, text, hint, foreground, background, browser)
  Note()

end -- print_hyperlink

function print_color(...)
  -- print lines with predefined colors:
  local content = {}

  for k,v in pairs({...}) do

    local group = v[2] or "default"
    content[#(content)+1] = RGBColourToName(
  config:get_option(group.."_color").value or 0)

    content[#(content)+1] = RGBColourToName(
    config:get_option("background_color").value)
    content[#(content)+1] = v[1]
  end -- for
  ColourNote(unpack(content))
end -- print_color
]]>
</script>


</muclient>
